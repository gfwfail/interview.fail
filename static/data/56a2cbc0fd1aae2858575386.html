<!DOCTYPE html><html><head><title>Single Number</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="geeksforgeeks, algorithms, iOS"><meta name="apple-itunes-app" content="app-id=991254978"><link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><link rel="stylesheet" href="/stylesheets/styles/github.css"><script src="/javascripts/jquery-1.11.2.js"></script><script src="/bootstrap/js/bootstrap.min.js"></script><script src="/javascripts/highlight.pack.js"></script><script src="/javascripts/geekreader.js"></script><script>hljs.initHighlightingOnLoad();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67142392-1', 'auto');
  ga('send', 'pageview');

</script>
</head><body><div class="container post"><div style="page-break-before:always;" class="post"><div class="post-header"><h1 data-id="56a2cbc0fd1aae2858575386" data-set="true" class="title">Single Number</h1></div><article class="post-content"><div class="question card-content"><div class="question-content">
              <p></p><p>Given an array of integers, every element appears <i>twice</i> except for one. Find that single one.</p>

<p>
<b>Note:</b><br>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</p>
              
                
              

              
                <div>
                  <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                  <span class="hidebutton">
                    
                    <a class="btn btn-xs btn-primary" href="https://leetcode.com/tag/hash-table/">Hash Table</a>
                    
                    <a class="btn btn-xs btn-primary" href="https://leetcode.com/tag/bit-manipulation/">Bit Manipulation</a>
                    
                  </span>
                </div>
              

              
                <div>
                  <div id="similar" class="btn btn-xs btn-warning">Show Similar Problems</div>
                  <span class="hidebutton">
                    
                    <a class="btn btn-xs btn-primary" href="#single-number-ii"> (M) Single Number II</a>
                    
                    <a class="btn btn-xs btn-primary" href="#single-number-iii"> (M) Single Number III</a>
                    
                    <a class="btn btn-xs btn-primary" href="#missing-number"> (M) Missing Number</a>
                    
                    <a class="btn btn-xs btn-primary" href="#find-the-duplicate-number"> (H) Find the Duplicate Number</a>
                    
                  </span>
                </div>
              

            </div>
          </div><div style="page-break-before:always;" class="answers"></div><div style="page-break-before:always;" class="card"><h2 class="card-title">Solution 1</h2><div class="answer card-content"><div class="entry-content"><p>known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.
`</p>

<pre><code>int singleNumber(int A[], int n) {
    int result = 0;
    for (int i = 0; i&lt;n; i++)
    {
        result ^=A[i];
    }
    return result;
}
</code></pre>

<p>`</p>
</div>
												</div><div class="author"><span>written by&nbsp;</span><a href="https://leetcode.com/discuss/user/Ivantsang">Ivantsang</a><span>&nbsp;original link&nbsp;</span><a href="https://leetcode.com/discuss/6170/my-o-n-solution-using-xor">here</a></div></div><div style="page-break-before:always;" class="card"><h2 class="card-title">Solution 2</h2><div class="answer card-content"><div class="entry-content"><p><strong>Logic:</strong> XOR will return 1 only on two different bits. So if two numbers are the same, XOR will return 0. Finally only one number left.
A ^ A = 0 and A ^ B ^ A = B.</p>

<pre><code>class Solution {
    public:
        int singleNumber(int A[], int n) {
            int result=A[0];
            for(int i=1;i&lt;n;i++)
            {
                result= result^A[i];  /* Get the xor of all elements */
            }
            return result;
        }
    };
</code></pre>
</div>
												</div><div class="author"><span>written by&nbsp;</span><a href="https://leetcode.com/discuss/user/Deepalaxmi">Deepalaxmi</a><span>&nbsp;original link&nbsp;</span><a href="https://leetcode.com/discuss/9739/easiest-way-to-solve-by-using-bit-manipulation">here</a></div></div><div style="page-break-before:always;" class="card"><h2 class="card-title">Solution 3</h2><div class="answer card-content"><div class="entry-content"><p>we use bitwise XOR to solve this problem : </p>

<p>first , we have to know the bitwise XOR in java</p>

<ol>
<li><strong>0 ^ N = N</strong></li>
<li><strong>N ^ N = 0</strong></li>
</ol>

<p>So..... if N is the single number</p>

<p>N1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  </p>

<p>= (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N</p>

<p>= 0 ^ 0 ^ ..........^ 0 ^ N</p>

<p>= N  </p>

<pre><code>public int singleNumber(int[] nums) {
    int ans =0;

    int len = nums.length;
    for(int i=0;i!=len;i++)
        ans ^= nums[i];

    return ans;

}
</code></pre>
</div>
												</div><div class="author"><span>written by&nbsp;</span><a href="https://leetcode.com/discuss/user/Nkeys">Nkeys</a><span>&nbsp;original link&nbsp;</span><a href="https://leetcode.com/discuss/53327/easy-java-solution-tell-you-why-using-bitwise-xor">here</a></div></div></article></div></div><footer class="footer"><div class="container"><span>From <a href="https://itunes.apple.com/ca/app/leetcoder/id1069760709?mt=8" target='_blank'>Leetcoder</a>.</span></div></footer></body></html>